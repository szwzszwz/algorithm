#### [剑指 Offer 10- I. 斐波那契数列](https://leetcode.cn/problems/fei-bo-na-qi-shu-lie-lcof/)

写一个函数，输入 `n` ，求斐波那契（Fibonacci）数列的第 `n` 项（即 `F(N)`）。斐波那契数列的定义如下：

```
F(0) = 0,   F(1) = 1
F(N) = F(N - 1) + F(N - 2), 其中 N > 1.
```

斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。

答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

**示例 1：**

```
输入：n = 2
输出：1
```

**示例 2：**

```
输入：n = 5
输出：5
```

**提示：**

- `0 <= n <= 100`

```java
class Solution {
    public int fib(int n) {
        final int MOD = 1000000007;
        int p = 0,q = 0,r = 1;
        if (n < 2) {
            return n;
        }
        for(int i = 2;i <= n;i++)
        {
            p = q; 
            q = r; 
            r = (p + q) % MOD;
        }
        return r;
    }
}
```

解题思路：由于递归解法耗用内存太大，所以采用迭代方式求解。双指针算法p，q两个指针，相加一次，分别向后移动一次。

___

#### [剑指 Offer 10- II. 青蛙跳台阶问题](https://leetcode.cn/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/)

一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 `n` 级的台阶总共有多少种跳法。

答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

**示例 1：**

```
输入：n = 2
输出：2
```

**示例 2：**

```
输入：n = 7
输出：21
```

**示例 3：**

```
输入：n = 0
输出：1
```

**提示：**

- `0 <= n <= 100`

```java
class Solution {
    public int numWays(int n) {
 		final int MOD = 1000000007;
        if(n == 0 || n == 1) return 1;
        int[] dp = new int[n + 1];
        dp[0] = 1;
        dp[1] = 1;
        for(int i = 2;i <= n;i++)
        {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n] % MOD;
    }
}
```

解题思路：典型的动态规划问题。将问题分为两个情况：1最后一次跳1阶台阶的`dp[i - 1]`，2最后一次跳2阶台阶`dp[i - 2]`。

举例子：

如果总共要跳三级台阶，可以将问题分为最后1和最后2。

如果最后1那么前面有2个台阶；如果最后2那么前面只可1；

<<===== 此时再往前退一步 =====>>

对于第一种情况，前面有2个台阶，可以将问题分为最后1和最后2。

如果最后2那么前面只可0；如果最后1那么前面只可1；

**综上所述：**

+ 跳0个台阶---1种---0步；
+ 跳1个台阶---1种---1步；
+ 跳2个台阶---1 + 1 = 2种---0步/2步  或者  1步/1步；
+ 跳3个台阶---1 + 2 = 3种---1表示最后跳2`dp[n - 2]`步，所以前面只能跳1步；2表示最后跳1`dp[n - 1]`步，那么前面剩下两个台阶，根据上一个信息可知，如果前面有2个台阶，有2种跳法。
+ 跳4个台阶---2 + 3 = 5种---2表示最后跳2`dp[n - 2]`步，那么前面剩下2个台阶，根据上一个的上一个信息可知，如果前面有2个台阶，有2种跳法；3表示最后跳1`dp[n - 1]`步，那么前面剩下3个台阶，根据上一个信息可知，如果前面有3个台阶，有3种跳法。
+ 跳5个台阶---3 + 5 = 8种---3表示最后跳2`dp[n - 2]`步，那么前面剩下3个台阶，根据上一个的上一个信息可知，如果前面有3个台阶，有3种跳法；5表示最后跳1`dp[n - 1]`步，那么前面剩下4个台阶，根据上一个信息可知，如果前面有4个台阶，有5种跳法。
+ 以此类推。。。。。。

___

#### [剑指 Offer 63. 股票的最大利润](https://leetcode.cn/problems/gu-piao-de-zui-da-li-run-lcof/)

假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？

**示例 1:**

```
输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。
```

**示例 2:**

```
输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
```

**限制：**

```
0 <= 数组长度 <= 100000
```

```java
class Solution {
    public int maxProfit(int[] prices) {
        int cost = Integer.MAX_VALUE,profit = 0;
        for(int p : prices){
            cost = Math.min(cost,p);
            profit = Math.max(profit,p - cost);
        }
        return profit;
    }
}
```

解题思路:循环找最小的买入价格，**与此同时**寻找最大的差价。

寻找最小的买入价格：如果存在更低的买入价格，可以将买入价格进行更换。

寻找最大的差价：记录从开始到结束的最高差价，如果新的买入价格和卖出价格**小于**原来的买入价格和卖出价格，差价不会更改。所以结束的时候所求的最大差价，不一定就是cost对应的最小的买入价格，有可能是原来的买入价格。

举例子：

+ 5 3 7 2 4
+ cost一开始是5，因为`3 < 5`,所以cost变成3，此时profit最大值是`7 - 3 = 4`。
+ 由于`2 < 3`,所以cost又变成2，但是此时profit最大值依旧是4，此时的4对应的最小的买入价格不是当前的cost，而是以前的3