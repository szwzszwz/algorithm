## 190. 颠倒二进制位
颠倒给定的 32 位无符号整数的二进制位。

**提示：**

+ 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
+ 在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。
 

示例 1：
```
输入：n = 00000010100101000001111010011100
输出：964176192 (00111001011110000010100101000000)
解释：输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，
因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。
```
示例 2：
```
输入：n = 11111111111111111111111111111101
输出：3221225471 (10111111111111111111111111111111)
解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，
因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。
``` 

提示：

+ 输入是一个长度为 32 的二进制字符串
原题链接[颠倒二进制位](https://leetcode.cn/problems/reverse-bits/)
```java
public class Solution {
    // you need treat n as an unsigned value
    public int reverseBits(int n) {
        int res = 0;
        for(int k = 0;k < 32 ;k++)
            res += ((1 & (n >> k)) << (31 - k)); 
        return res;
    }
}
```
解题思路：  

+ 首先 `n >> k` 表示每次 `n` 向右移一位  

+ `1 &` 一个二进制数表示的是取出该二进制数的最后一位  

+ 将最后一位取出以后，向左移动 `31 - k` 位，将其加入到结果中即可。多次循环，最终可以得到目标值。
___
## 136. 只出现一次的数字
给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

**说明：**

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

示例 1:
```
输入: [2,2,1]
输出: 1
```
示例 2:
```
输入: [4,1,2,1,2]
输出: 4
```
原题链接[只出现一次的数字](https://leetcode.cn/problems/single-number/)
```java
class Solution {
    public int singleNumber(int[] nums) {
        int ans = 0;
        if(nums.length >= 1)
            for(int num : nums)
                ans = ans ^ num;

        return ans;
    }
}
``` 
解题思路：  

根据：
+ ` 1 ^ 1 = 0 ^ 0 = 0 `  
+ ` 1 ^ 0 = 0 ^ 1 = 1 `   
+ 且异或具有交换律

推出：  
+ ` a ^ 0 = a `  
+ ` a ^ a = 0 `  
+ ` a ^ b ^ a = b `  

` 0 ^ 4 ^ 1 ^ 2 ^ 1 ^ 2 = 1 ^ 4 ^ 1 ^ 2 ^ 2 = 4 ^ 0 = 4 ` 只要有两个数相同，那么在异或运算的时候相同的数字异或的结果是0