## 0、1背包

题目描述：

有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。

第 i 件物品的体积是 `vi`，价值是 `wi`。

求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
输出最大价值。

#### 输入格式

第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。

接下来有 N 行，每行两个整数`vi、wi`，用空格隔开，分别表示第 i 件物品的体积和价值。

#### 输出格式

输出一个整数，表示最大价值

#### 数据范围

`0<N,V≤10000<N,V≤1000`
`0<vi,wi≤10000<vi,wi≤1000`

#### 输入样例

```
4 5
1 2
2 4
3 4
4 5
```

#### 输出样例：

```
8
```

---

```c++
二维
#include<iostream>
#include<algorithm>
using namespace std;
const int N = 1010;
int v[N],w[N];
int f[N][N];
int n,m;
int main()
{
    cin >> n >> m;
    for(int i = 1;i <= n;i++) cin >> v[i] >> w[i];
    for(int i = 1;i <= n;i++)
        for(int j = 0;j <= m;j++){
            f[i][j] = f[i - 1][j]; // 当前为不选第i个物品
            if(j >= v[i]) f[i][j] = max(f[i][j],f[i - 1][j - v[i]] + w[i]); // 选第i个物品
        }
    cout << f[n][m] << endl;
    return 0;
}


一维
#include<iostream>
#include<algorithm>
using namespace std;
const int N = 1010;
int v[N],w[N];
int f[N][N];
int n,m;
int main()
{
    cin >> n >> m;
    for(int i = 1;i <= n;i++) cin >> v[i] >> w[i];
    for(int i = 1;i <= n;i++)
        for(int j = m;j >= v[i];j--){ // 逆序
			f[j] = max(f[j],f[j - v[i]] + w[i]);
        }
    cout << f[m] << endl;
    return 0;
}
```

二维数组中`f[i][j]`表示Max(价值)，其中i表示前i个物品中，j表示背包大小为j的时候。

优化到一维数组：

将状态`f[i][j]`优化到一维f[j]，实际上只需要做一个等价变形。

为什么可以这样变形呢？我们定义的状态`f[i][j]`[i][j]可以求得任意合法的i与j最优解，但题目只需要求得最终状态`f[n][m]`，因此我们只需要一维的空间来更新状态。

（1）状态f[j]定义：N 件物品，背包容量j下的最优解。

（2）注意枚举背包容量j必须从m开始。

（3）为什么一维情况下枚举背包容量需要逆序？在二维情况下，状态`f[i][j]`是由上一轮i - 1的状态得来的，`f[i][j]`与`f[i - 1][j]`是独立的。而优化到一维后，如果我们还是正序，则有f[较小体积]更新到f[较大体积]，则有可能本应该用第i-1轮的状态却用的是第i轮的状态。

（4）例如，一维状态第i轮对体积为 3 的物品进行决策，则f[7]由f[4]更新而来，这里的f[4]正确应该是`f[i - 1][4]`，但从小到大枚举j这里的f[4]在第i轮计算却变成了`f[i][4]`。当逆序枚举背包容量j时，我们求f[7]同样由f[4]更新，但由于是逆序，这里的f[4]还没有在第i轮计算，所以此时实际计算的f[4]仍然是`f[i - 1][4]`。

（5）简单来说，一维情况正序更新状态f[j]需要用到前面计算的状态已经被「污染」，逆序则不会有这样的问题。

状态转移方程为：`f[j] = max(f[j], f[j - v[i]] + w[i] )`
